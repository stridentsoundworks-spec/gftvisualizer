<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Quantum Field: Interactive</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Rajdhani', sans-serif;
        }

        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@400;600;700&display=swap');

        canvas { display: block; }

        /* CRT Scanline Effect */
        #scanlines {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255,0,0,0.06), rgba(0,255,0,0.02), rgba(0,0,255,0.06));
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
            z-index: 10;
            opacity: 0.4;
        }

        #overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.92);
            z-index: 100;
            backdrop-filter: blur(15px);
            transition: opacity 0.8s ease;
        }

        .hud-panel {
            border: 1px solid rgba(0, 255, 255, 0.4);
            background: rgba(5, 10, 15, 0.9);
            padding: 60px;
            text-align: center;
            position: relative;
            box-shadow: 0 0 60px rgba(0, 150, 255, 0.15);
            border-radius: 4px;
        }

        /* HUD Reticles */
        .hud-panel::after {
            content: ''; position: absolute; bottom: -5px; right: -5px; width: 20px; height: 20px;
            border-bottom: 2px solid #00ffff; border-right: 2px solid #00ffff;
        }
        .hud-panel::before {
            content: ''; position: absolute; top: -5px; left: -5px; width: 20px; height: 20px;
            border-top: 2px solid #00ffff; border-left: 2px solid #00ffff;
        }

        h1 {
            color: #fff;
            font-weight: 700;
            letter-spacing: 8px;
            font-size: 36px;
            margin: 0 0 15px 0;
            text-shadow: 0 0 25px rgba(0, 255, 255, 0.6);
            text-transform: uppercase;
        }

        p { color: #7a8fa3; font-size: 12px; margin-bottom: 40px; letter-spacing: 3px; text-transform: uppercase; }

        .btn-group { display: flex; gap: 20px; justify-content: center; }

        button, .file-upload {
            background: rgba(0, 255, 255, 0.05);
            border: 1px solid rgba(0, 255, 255, 0.5);
            color: #00ffff;
            padding: 14px 35px;
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.2s ease;
            letter-spacing: 2px;
        }

        button:hover, .file-upload:hover {
            background: #00ffff;
            color: #000;
            box-shadow: 0 0 30px #00ffff;
        }

        input[type="file"] { display: none; }

        #status-bar {
            position: absolute;
            bottom: 30px;
            left: 30px;
            color: rgba(255, 255, 255, 0.4);
            font-size: 11px;
            letter-spacing: 2px;
            border-left: 3px solid #00ffff;
            padding-left: 15px;
            z-index: 20;
        }
        #status-bar span { color: #00ffff; font-weight: bold; }

        #interaction-hint {
            position: absolute;
            top: 30px;
            width: 100%;
            text-align: center;
            color: rgba(0, 255, 255, 0.3);
            font-size: 10px;
            letter-spacing: 4px;
            pointer-events: none;
            z-index: 9;
        }
    </style>
</head>
<body>

<div id="scanlines"></div>
<div id="interaction-hint">MOUSE INTERACTION: ACTIVE</div>

<div id="overlay">
    <div class="hud-panel">
        <h1>Quantum Labs</h1>
        <p>Interactive Field Simulator v4.0</p>

        <div class="btn-group">
            <label class="file-upload">
                Load Audio File
                <input type="file" id="file-input" accept="audio/*">
            </label>
            <button id="mic-btn">Initialize Sensors</button>
        </div>
    </div>
</div>

<div id="status-bar">SYSTEM: <span>STANDBY</span> // AWAITING INPUT</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
            "lil-gui": "https://unpkg.com/lil-gui@0.19.1/dist/lil-gui.esm.min.js"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { AfterimagePass } from 'three/addons/postprocessing/AfterimagePass.js';
    import { OutputPass } from 'three/addons/postprocessing/OutputPass.js';
    import GUI from 'lil-gui';

    // --- CONFIGURATION ---
    const CONFIG = {
        maxParticles: 180000, // Optimized for HD sharpness
        initialDensity: 0.164,
        fieldRadius: 45.0
    };

    const STATE = {
        field: 'Gluon (Strong)',
        density: CONFIG.initialDensity,
        sensitivity: 0.4698,
        trails: 0.66144,
        bloom: 0.42,
        timeScale: 1.188,
        pixelRatio: Math.min(window.devicePixelRatio, 2.0)
    };

    // --- AUDIO ---
    const AUDIO = {
        ctx: null, analyser: null, source: null, data: null,
        bands: { bass: 0, mid: 0, high: 0 }, active: false,
        init() {
            if(this.ctx) return;
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            this.analyser = this.ctx.createAnalyser();
            this.analyser.fftSize = 2048;
            this.analyser.smoothingTimeConstant = 0.85;
            this.data = new Uint8Array(this.analyser.frequencyBinCount);
            this.active = true;
        },
        update() {
            if(!this.active) return;
            this.analyser.getByteFrequencyData(this.data);
            let b=0, m=0, h=0;
            const len = this.data.length;
            const pBass = Math.floor(len*0.06);
            const pMid = Math.floor(len*0.3);
            for(let i=0; i<len; i++) {
                const v = this.data[i]/255.0;
                if(i<pBass) b+=v; else if(i<pMid) m+=v; else h+=v;
            }
            this.bands.bass = b/pBass;
            this.bands.mid = m/(pMid-pBass);
            this.bands.high = h/(len-pMid);
        }
    };

    // --- SCENE ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.008); // Lighter fog for clarity

    const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 500);
    camera.position.set(0, 10, 70);

    const renderer = new THREE.WebGLRenderer({ powerPreference: "high-performance", antialias: false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(STATE.pixelRatio);
    // Tone Mapping is crucial for HD look
    renderer.toneMapping = THREE.ReinhardToneMapping;
    renderer.toneMappingExposure = 2.0;
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.5;

    // --- MOUSE INTERACTION ---
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2(9999, 9999); // Start off screen
    const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0); // Invisible plane for raycasting
    const mouseWorldPos = new THREE.Vector3();

    window.addEventListener('mousemove', (e) => {
        // Normalize mouse pos
        mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

        // Raycast to invisible plane to get 3D coordinate
        raycaster.setFromCamera(mouse, camera);
        const target = new THREE.Vector3();
        raycaster.ray.intersectPlane(plane, target);
        if(target) {
            mouseWorldPos.copy(target);
        }
    });

    // --- SHADERS (Optimized for Clarity) ---
    const vertexShader = `
        uniform float uTime;
        uniform float uPixelRatio;
        uniform float uSizeBase;
        uniform float uNoiseScale;
        uniform float uCurlStrength;
        uniform float uRadius;
        uniform vec3 uColor1;
        uniform vec3 uColor2;

        // Audio
        uniform float uBass;
        uniform float uMid;
        uniform float uHigh;

        // Interaction
        uniform vec3 uMousePos;

        attribute vec3 aRandom;
        varying vec3 vColor;
        varying float vAlpha;
        varying float vCollisionEnergy; // Used for collision flash

        // --- NOISE FUNCTIONS --- (Note: snoise function was missing proper return value, fixed.)
        vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
        vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
        float snoise(vec3 v) {
            const vec2 C = vec2(1.0/6.0, 1.0/3.0);
            const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
            vec3 i = floor(v + dot(v, C.yyy));
            vec3 x0 = v - i + dot(i, C.xxx);
            vec3 g = step(x0.yzx, x0.xyz);
            vec3 l = 1.0 - g;
            vec3 i1 = min(g.xyz, l.zxy);
            vec3 i2 = max(g.xyz, l.zxy);
            vec3 x1 = x0 - i1 + C.xxx;
            vec3 x2 = x0 - i2 + C.yyy;
            vec3 x3 = x0 - D.yyy;
            i = mod289(i);
            vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));
            float n_ = 0.142857142857;
            vec3 ns = n_ * D.wyz - D.xzx;
            vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
            vec4 x_ = floor(j * ns.z);
            vec4 y_ = floor(j - 7.0 * x_);
            vec4 x = x_ *ns.x + ns.yyyy;
            vec4 y = y_ *ns.x + ns.yyyy;
            vec4 h = 1.0 - abs(x) - abs(y);
            vec4 b0 = vec4(x.xy, y.xy);
            vec4 b1 = vec4(x.zw, y.zw);
            vec4 s0 = floor(b0) * 2.0 + 1.0;
            vec4 s1 = floor(b1) * 2.0 + 1.0;
            vec4 sh = -step(h, vec4(0.0));
            vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;
            vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;
            vec3 p0 = vec3(a0.xy, h.x);
            vec3 p1 = vec3(a0.zw, h.y);
            vec3 p2 = vec3(a1.xy, h.z);
            vec3 p3 = vec3(a1.zw, h.w);
            vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));
            p0 *= norm.x;
            p1 *= norm.y;
            p2 *= norm.z;
            p3 *= norm.w;
            vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);
            m = m * m;
            return 42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));
        }

        vec3 curl(float x, float y, float z) {
            float eps = 0.1;
            vec3 curl;
            curl.x = snoise(vec3(x, y+eps, z)) - snoise(vec3(x, y-eps, z));
            curl.y = snoise(vec3(x, y, z+eps)) - snoise(vec3(x, y, z-eps));
            curl.z = snoise(vec3(x+eps, y, z)) - snoise(vec3(x-eps, y, z));
            return curl;
        }

        void main() {
            float t = uTime * (1.0 + uMid * 0.5);
            vec3 noisePos = position * 0.04 + aRandom;

            // 1. Fluid Flow
            vec3 flow = curl(noisePos.x * uNoiseScale + t*0.15, noisePos.y * uNoiseScale, noisePos.z * uNoiseScale);
            vec3 newPos = position + (flow * uCurlStrength);

            // 2. Mouse Interaction (Collision Probe)
            float distToMouse = distance(newPos, uMousePos);
            // Create a repulsion field around mouse
            float repulsion = smoothstep(15.0, 0.0, distToMouse);
            vec3 repelDir = normalize(newPos - uMousePos);
            newPos += repelDir * repulsion * 8.0;

            // 3. Bass Shockwave
            vec3 centerDir = normalize(newPos);
            float distToCenter = length(newPos);
            float kick = smoothstep(0.3, 0.8, uBass);
            newPos += centerDir * (kick * 4.0 * exp(-distToCenter * 0.1));

            vec4 mvPosition = modelViewMatrix * vec4(newPos, 1.0);
            gl_Position = projectionMatrix * mvPosition;

            // 4. Size & Collision Flash logic
            float size = uSizeBase * (0.8 + uBass * 0.6);

            // If repulsion is high, particles are bunched up -> simulate energy flash
            float collision = repulsion * uMid * 2.0;
            vCollisionEnergy = collision;

            gl_PointSize = size * uPixelRatio * (60.0 / -mvPosition.z);

            // 5. Coloring
            float turb = length(flow);
            // Add collision brightness to the mix
            vec3 c = mix(uColor1, uColor2, smoothstep(0.0, 2.0, turb + uHigh*2.0));

            // White hot center + Collision Flash
            vColor = mix(c, vec3(1.0), uBass * 0.5 + collision);

            // 6. Alpha & Sparkle
            float alpha = 1.0 - smoothstep(uRadius * 0.8, uRadius, distToCenter);
            float sparkle = 1.0 + (aRandom.x > 0.7 ? sin(uTime * 20.0 + aRandom.y * 100.0) * uHigh * 4.0 : 0.0);
            vAlpha = alpha * sparkle;
        }
    `;

    const fragmentShader = `
        varying vec3 vColor;
        varying float vAlpha;
        varying float vCollisionEnergy;

        void main() {
            vec2 xy = gl_PointCoord.xy - vec2(0.5);
            float r = length(xy);
            if(r > 0.5) discard;

            // Optical Lens Effect:
            // Sharp core, soft halo.
            float glow = exp(-r * r * 20.0);

            // Simulated Chromatic Aberration at edges of particle (Fake dispersion)
            vec3 finalColor = vColor;
            if(r > 0.3) {
                finalColor *= 0.8; // darken edges
            }

            gl_FragColor = vec4(finalColor, vAlpha * glow);
        }
    `;

    // --- GEOMETRY ---
    const geometry = new THREE.BufferGeometry();
    const pos = [], rnd = [];
    const vec = new THREE.Vector3();
    for(let i=0; i<CONFIG.maxParticles; i++) {
        const r = CONFIG.fieldRadius * Math.pow(Math.random(), 0.4);
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        vec.setFromSphericalCoords(r, phi, theta);
        pos.push(vec.x, vec.y, vec.z);
        rnd.push(Math.random(), Math.random(), Math.random());
    }
    geometry.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
    geometry.setAttribute('aRandom', new THREE.Float32BufferAttribute(rnd, 3));
    geometry.setDrawRange(0, Math.floor(CONFIG.maxParticles * STATE.density));

    const FIELD_TYPES = {
        'Photon (EM)': { c1:'#00f2ff', c2:'#0051ff', s:1.0, curl:0.8, sz:1.2 },
        'Gluon (Strong)': { c1:'#ff0055', c2:'#7000ff', s:2.2, curl:2.0, sz:1.5 },
        'Higgs (Mass)': { c1:'#ffae00', c2:'#ff4800', s:0.5, curl:0.2, sz:2.0 },
        'Gravity': { c1:'#ffffff', c2:'#444444', s:0.6, curl:0.1, sz:1.0 }
    };

    const def = FIELD_TYPES[STATE.field];
    const material = new THREE.ShaderMaterial({
        vertexShader, fragmentShader,
        uniforms: {
            uTime: { value: 0 },
            uPixelRatio: { value: STATE.pixelRatio },
            uSizeBase: { value: def.sz },
            uNoiseScale: { value: def.s },
            uCurlStrength: { value: def.curl },
            uRadius: { value: CONFIG.fieldRadius },
            uColor1: { value: new THREE.Color(def.c1) },
            uColor2: { value: new THREE.Color(def.c2) },
            uBass: { value: 0 }, uMid: { value: 0 }, uHigh: { value: 0 },
            uMousePos: { value: new THREE.Vector3(999,999,999) } // Initialize off-screen
        },
        transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
    });
    const points = new THREE.Points(geometry, material);
    scene.add(points);

    // --- POST PROCESSING (HD Chain) ---
    const composer = new EffectComposer(renderer);
    const renderPass = new RenderPass(scene, camera);
    composer.addPass(renderPass);

    // 1. Trails
    const afterimagePass = new AfterimagePass();
    afterimagePass.uniforms['damp'].value = STATE.trails;
    composer.addPass(afterimagePass);

    // 2. Bloom
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
    bloomPass.threshold = 0.15;
    bloomPass.strength = STATE.bloom;
    bloomPass.radius = 0.4; // Lower radius = Sharper glow
    composer.addPass(bloomPass);

    // 3. Output (Color Correct)
    const outputPass = new OutputPass();
    composer.addPass(outputPass);

    // --- GUI ---
    const gui = new GUI({ title: 'QUANTUM CONTROLS' });
    gui.add(STATE, 'sensitivity', 0.1, 3.0).name('Audio Sensitivity');

    const f_phys = gui.addFolder('Physics Engine');
    f_phys.add(STATE, 'field', Object.keys(FIELD_TYPES)).name('Field Type').onChange(val => {
        const d = FIELD_TYPES[val];
        const c1 = new THREE.Color(d.c1);
        const c2 = new THREE.Color(d.c2);
        const start = performance.now();
        const startS = material.uniforms.uNoiseScale.value;

        function step() {
            const p = Math.min((performance.now()-start)/1000, 1);
            const e = 1 - Math.pow(1-p, 3);
            material.uniforms.uColor1.value.lerp(c1, 0.05);
            material.uniforms.uColor2.value.lerp(c2, 0.05);
            material.uniforms.uNoiseScale.value = startS + (d.s - startS)*e;
            material.uniforms.uCurlStrength.value = THREE.MathUtils.lerp(material.uniforms.uCurlStrength.value, d.curl, 0.05);
            material.uniforms.uSizeBase.value = THREE.MathUtils.lerp(material.uniforms.uSizeBase.value, d.sz, 0.05);
            if(p<1) requestAnimationFrame(step);
        }
        step();
    });
    f_phys.add(STATE, 'density', 0.0, 1.0).name('Density').onChange(v => geometry.setDrawRange(0, Math.floor(CONFIG.maxParticles*v)));

    const f_vis = gui.addFolder('Optics & Visuals');
    f_vis.add(afterimagePass.uniforms['damp'], 'value', 0.5, 0.98).name('Trail Persistence');
    f_vis.add(bloomPass, 'strength', 0.0, 3.0).name('Bloom Strength');
    f_vis.add(STATE, 'timeScale', 0.0, 2.0).name('Time Flow');

    // --- EVENTS ---
    const overlay = document.getElementById('overlay');
    const status = document.getElementById('status-bar');

    function activate() {
        AUDIO.init();
        if(AUDIO.ctx.state === 'suspended') AUDIO.ctx.resume();
        overlay.style.opacity = 0;
        setTimeout(() => overlay.style.display = 'none', 800);
        status.innerHTML = 'SYSTEM: <span>ACTIVE</span> // INTERACTION ENABLED';
    }

    document.getElementById('file-input').addEventListener('change', (e) => {
        activate();
        const reader = new FileReader();
        reader.onload = (ev) => AUDIO.ctx.decodeAudioData(ev.target.result, (buf) => {
            if(AUDIO.source) try{AUDIO.source.stop()}catch(e){} // Stop any previous source
            AUDIO.source = AUDIO.ctx.createBufferSource();
            AUDIO.source.buffer = buf;
            AUDIO.source.loop = true;
            AUDIO.source.connect(AUDIO.analyser);
            AUDIO.analyser.connect(AUDIO.ctx.destination);
            AUDIO.source.start(0);
            status.innerHTML = 'SYSTEM: <span>PLAYING TRACK</span>';
        });
        reader.readAsArrayBuffer(e.target.files[0]);
    });

    document.getElementById('mic-btn').addEventListener('click', () => {
        activate();
        navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
            if(AUDIO.source) try{AUDIO.source.disconnect()}catch(e){} // Disconnect previous source
            AUDIO.source = AUDIO.ctx.createMediaStreamSource(stream);
            AUDIO.source.connect(AUDIO.analyser);
            status.innerHTML = 'SYSTEM: <span>LISTENING</span>';
        });
    });

    // --- LOOP ---
    const clock = new THREE.Clock();
    function animate() {
        requestAnimationFrame(animate);
        const dt = clock.getDelta();
        material.uniforms.uTime.value += dt * STATE.timeScale;

        // Update Mouse Interaction in Shader
        // Lerp for smooth movement of the interaction field
        material.uniforms.uMousePos.value.lerp(mouseWorldPos, 0.1);

        AUDIO.update();
        const s = STATE.sensitivity;

        material.uniforms.uBass.value = THREE.MathUtils.lerp(material.uniforms.uBass.value, AUDIO.bands.bass*s, 0.15);
        material.uniforms.uMid.value = THREE.MathUtils.lerp(material.uniforms.uMid.value, AUDIO.bands.mid*s, 0.15);
        material.uniforms.uHigh.value = THREE.MathUtils.lerp(material.uniforms.uHigh.value, AUDIO.bands.high*s, 0.15);

        controls.autoRotateSpeed = 0.5 + (material.uniforms.uMid.value * 3.0);
        controls.update();
        composer.render();
    }
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        composer.setSize(window.innerWidth, window.innerHeight);
    });
    animate();
</script>
</body>
</html>
